# Building My Own LoRa CLI Terminal

This is about creating a simple UART CLI to interact with LoRa hardware.
In my case — the RAK3172 module running raw LoRa (not LoRaWAN).

Why? Because I hate GUIs.
I want control, repeatability, and speed.

## The Problem

Most LoRa modules ship with:
- AT Command Firmware (gross)
- LoRaWAN Middleware (unnecessary)

I want:
- Bare metal control of SX1262
- LoRa configuration exposed as commands
- Send/Receive with debugging output

## The Approach

Create a simple UART-driven command interface:
- Like a poor man’s shell.
- No fancy parsing libraries.
- Static command table.

Example Command API:

| Command | Args        | Action                            |
|---------|-------------|----------------------------------|
| tx      | HEX string  | Send LoRa packet                 |
| rx      | -           | Enter RX mode                   |
| config  | param val   | Update LoRa config dynamically  |
| status  | -           | Dump radio state                |
| sleep   | -           | Put MCU + Radio to sleep        |

## Why It’s Better

1. I can script against it easily.
2. Fast iteration without rebuilding firmware.
3. LoRa settings are tunable on the fly.

## CLI Example

```
> tx 48656C6C6F
TX Done. RSSI -42dBm

> rx
Listening...

> rx
Packet Received: 48656C6C6F
RSSI: -45dBm SNR: 9dB
```

## Future Plans

This CLI will evolve to support:
- SD Card logging of LoRa packets.
- OTA command scripts from SD.
- Custom framing / encryption layers.
- GPIO / ADC control from commands.

Eventually this becomes a "LoRa Debug Adapter":
- Drop in any LoRa device.
- UART CLI ready to go.
- Reflash with custom builds as needed.

## Final Thoughts

This project is about doing embedded the right way:
- Hardware-first.
- CLI driven tools.
- Debuggable systems.

Forget wizards.
Forget autogenerated configs.

Battle With Bytes is about control.
Control of your tools.
Control of your hardware.
Control of your system.

More coming soon.
